#!/bin/bash

set -e

# 스크립트 디렉토리 결정
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# 개발 모드 감지 - cli/bin 구조가 있으면 개발 모드
if [ -f "$SCRIPT_DIR/../../docker-compose.dev.yaml" ]; then
    # 개발 모드: PROJECT_ROOT/cli/bin/codekiwi 구조
    PROJECT_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"
    CONFIG_BASE="$PROJECT_ROOT"
else
    # 설치 모드: ~/.codekiwi/codekiwi 구조 (cli/bin 디렉토리 없음)
    PROJECT_ROOT=""
    CONFIG_BASE="$HOME/.codekiwi"
fi

# Load configuration
if [ -f "$CONFIG_BASE/lib/config-loader.sh" ]; then
    source "$CONFIG_BASE/lib/config-loader.sh"
else
    echo "Error: config-loader.sh not found at $CONFIG_BASE/lib/config-loader.sh" >&2
    exit 1
fi

if [ -n "$PROJECT_ROOT" ] && [ -f "$PROJECT_ROOT/$CODEKIWI_COMPOSE_FILE_DEV" ]; then
    # 개발 모드
    INSTALL_DIR="$PROJECT_ROOT"
    INSTANCES_DIR="$PROJECT_ROOT/instances"
else
    # 설치된 모드
    INSTALL_DIR="${CODEKIWI_INSTALL_DIR:-$HOME/.codekiwi}"
    INSTANCES_DIR="$INSTALL_DIR/instances"
fi

COMPOSE_FILE="$INSTALL_DIR/${CODEKIWI_COMPOSE_FILE_PROD:-docker-compose.yaml}"

# 색상 코드
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# 헬퍼 함수
print_success() {
    echo -e "${GREEN}✅ $1${NC}"
}

print_info() {
    echo -e "${BLUE}ℹ️  $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}⚠️  $1${NC}"
}

print_error() {
    echo -e "${RED}❌ $1${NC}"
}

# Docker 확인
check_docker() {
    if ! command -v docker &> /dev/null; then
        print_error "Docker가 설치되어 있지 않습니다."
        echo "   https://www.docker.com/get-started 에서 Docker를 설치해주세요."
        exit 1
    fi

    if ! docker info &> /dev/null; then
        print_error "Docker가 실행되고 있지 않습니다."
        echo "   Docker Desktop을 실행해주세요."
        exit 1
    fi
}

# 디렉토리 경로를 해시로 변환 (컨테이너 이름용)
get_project_hash() {
    local dir="$1"
    echo -n "$dir" | md5sum 2>/dev/null | cut -d' ' -f1 | cut -c1-8 || echo -n "$dir" | md5 | cut -c1-8
}

# 사용 가능한 포트 찾기
find_available_port() {
    local start_port=$1
    local port=$start_port

    while [ $port -lt $((start_port + 100)) ]; do
        if ! lsof -Pi :$port -sTCP:LISTEN -t >/dev/null 2>&1 && ! docker ps --format '{{.Ports}}' | grep -q ":$port->"; then
            echo $port
            return 0
        fi
        port=$((port + 1))
    done

    print_error "사용 가능한 포트를 찾을 수 없습니다."
    exit 1
}

# 인스턴스 디렉토리 생성
ensure_instances_dir() {
    mkdir -p "$INSTANCES_DIR"
}

# 상태 파일 경로 가져오기
get_state_file() {
    local project_hash="$1"
    echo "$INSTANCES_DIR/${project_hash}.state"
}

# 상태 저장
save_state() {
    local project_hash="$1"
    local workspace="$2"
    local web_port="$3"
    local container_name="$4"
    local state_file=$(get_state_file "$project_hash")

    cat > "$state_file" <<EOF
WORKSPACE_DIR="$workspace"
WEB_PORT=$web_port
CONTAINER_NAME="$container_name"
STARTED_AT=$(date +%s)
PID=$$
EOF
}

# 상태 로드
load_state() {
    local state_file="$1"
    if [ -f "$state_file" ]; then
        source "$state_file"
        return 0
    fi
    return 1
}

# 상태 삭제
clear_state() {
    local state_file="$1"
    rm -f "$state_file"
}

# 프로젝트가 실행 중인지 확인
is_project_running() {
    local container_name="$1"
    docker ps --format '{{.Names}}' | grep -q "^${container_name}$"
}

# 모든 실행 중인 인스턴스 가져오기
get_all_instances() {
    ensure_instances_dir
    find "$INSTANCES_DIR" -name "*.state" 2>/dev/null || true
}

# 정리 함수 (Ctrl+C 또는 종료 시 호출)
cleanup() {
    echo ""
    print_info "종료 중..."

    if [ -n "$CONTAINER_NAME" ]; then
        # Docker 명령어로 직접 중지 및 제거
        print_info "컨테이너 중지: $CONTAINER_NAME"
        docker stop "$CONTAINER_NAME" 2>/dev/null || true
        docker rm "$CONTAINER_NAME" 2>/dev/null || true
    fi

    if [ -n "$STATE_FILE" ]; then
        clear_state "$STATE_FILE"
    fi

    print_success "CodeKiwi가 종료되었습니다."
    exit 0
}

# 시작 명령어 (포그라운드 모드)
cmd_start() {
    local target_dir="$1"

    # 디렉토리 결정
    if [ -z "$target_dir" ]; then
        target_dir="$PWD"
        print_info "현재 디렉토리를 사용합니다: $target_dir"
    else
        target_dir="${target_dir/#\~/$HOME}"
    fi

    # 절대 경로로 변환
    target_dir=$(cd "$target_dir" 2>/dev/null && pwd || echo "$target_dir")

    # 디렉토리 존재 확인
    if [ ! -d "$target_dir" ]; then
        print_error "디렉토리가 존재하지 않습니다: $target_dir"
        read -p "생성하시겠습니까? (y/n): " create_dir
        if [ "$create_dir" = "y" ] || [ "$create_dir" = "Y" ]; then
            mkdir -p "$target_dir"
            print_success "디렉토리를 생성했습니다: $target_dir"
        else
            exit 1
        fi
    fi

    # 디렉토리가 비어있는지 확인
    local install_template="yes"
    if [ -z "$(ls -A "$target_dir" 2>/dev/null)" ]; then
        echo ""
        print_info "디렉토리가 비어있습니다."
        read -p "CodeKiwi 템플릿을 설치하시겠습니까? (Y/n): " answer
        case "$answer" in
            [Nn]|[Nn][Oo])
                install_template="no"
                print_warning "템플릿 설치를 건너뜁니다."
                ;;
            *)
                install_template="yes"
                print_info "템플릿을 설치합니다."
                ;;
        esac
        echo ""
    fi

    check_docker
    ensure_instances_dir

    # 프로젝트 해시 생성
    local project_hash=$(get_project_hash "$target_dir")
    CONTAINER_NAME="${project_hash}"
    STATE_FILE=$(get_state_file "$project_hash")

    # 이미 실행 중인지 확인
    if is_project_running "$CONTAINER_NAME"; then
        print_error "이 프로젝트가 이미 다른 터미널에서 실행 중입니다: $target_dir"
        if load_state "$STATE_FILE"; then
            echo "🌐 접속 주소: http://localhost:${WEB_PORT}"
        fi
        exit 1
    fi

    # 사용 가능한 포트 찾기
    local web_port=$(find_available_port ${CODEKIWI_WEB_PORT_DEFAULT:-8080})

    echo ""
    echo "======================================"
    echo "  CodeKiwi 시작"
    echo "======================================"
    echo ""
    print_info "작업 디렉토리: $target_dir"
    print_info "웹 포트: $web_port"
    echo ""

    # 종료 시그널 트랩 설정
    trap cleanup SIGINT SIGTERM

    # 상태 저장
    save_state "$project_hash" "$target_dir" "$web_port" "$CONTAINER_NAME"

    # Docker Compose 실행 (포그라운드)
    cd "$INSTALL_DIR"

    print_success "컨테이너를 시작합니다..."
    echo ""

    # 개발 모드 확인 (docker-compose.dev.yaml이 있으면 로컬 빌드)
    if [ -f "$INSTALL_DIR/$CODEKIWI_COMPOSE_FILE_DEV" ]; then
        print_info "개발 모드: 로컬 이미지 빌드 중..."
        # 백그라운드로 시작한 후 로그를 따라감
        WORKSPACE_DIR="$target_dir" \
        WEB_PORT="$web_port" \
        CONTAINER_NAME="$CONTAINER_NAME" \
        INSTALL_TEMPLATE="$install_template" \
        docker-compose -f "$CODEKIWI_COMPOSE_FILE_DEV" up -d --build
    else
        # 프로덕션 모드: Docker Hub 이미지 사용
        WORKSPACE_DIR="$target_dir" \
        WEB_PORT="$web_port" \
        CONTAINER_NAME="$CONTAINER_NAME" \
        INSTALL_TEMPLATE="$install_template" \
        docker-compose up -d
    fi

    echo ""
    print_success "CodeKiwi가 시작되었습니다!"
    echo ""
    echo "🌐 브라우저에서 접속: ${CYAN}http://localhost:${web_port}${NC}"
    echo "📁 작업 디렉토리: $target_dir"
    echo ""
    print_warning "Ctrl+C를 눌러 종료하세요"
    echo ""
    echo "======================================"
    echo ""

    # 브라우저 자동 열기
    print_info "브라우저를 엽니다..."
    local url="http://localhost:${web_port}"

    if command -v open &> /dev/null; then
        # macOS
        open "$url" &
    elif command -v xdg-open &> /dev/null; then
        # Linux
        xdg-open "$url" &
    elif [[ "$OSTYPE" == "msys" ]] || [[ "$OSTYPE" == "win32" ]] || [[ "$OSTYPE" == "cygwin" ]]; then
        # Windows native (Git Bash, MinGW, Cygwin)
        cmd.exe /c start "" "$url" &
    elif command -v start &> /dev/null; then
        # Windows (WSL)
        start "$url" &
    else
        # Fallback - Python
        if command -v python3 &> /dev/null; then
            python3 -m webbrowser "$url" &
        elif command -v python &> /dev/null; then
            python -m webbrowser "$url" &
        fi
    fi

    # 로그 스트리밍 (포그라운드로 실행)
    docker logs -f "$CONTAINER_NAME"
}

# 목록 명령어
cmd_list() {
    ensure_instances_dir

    echo "======================================"
    echo "  실행 중인 CodeKiwi 인스턴스"
    echo "======================================"
    echo ""

    local count=0
    local instances=$(get_all_instances)

    if [ -z "$instances" ]; then
        print_warning "실행 중인 인스턴스가 없습니다."
        echo ""
        echo "💡 시작하려면: codekiwi <directory>"
        return 0
    fi

    for state_file in $instances; do
        if load_state "$state_file"; then
            if is_project_running "$CONTAINER_NAME"; then
                count=$((count + 1))

                echo -e "${CYAN}[인스턴스 #$count]${NC}"
                echo "  📁 디렉토리: $WORKSPACE_DIR"
                echo "  🌐 웹: http://localhost:${WEB_PORT}"
                echo "  🐳 컨테이너: $CONTAINER_NAME"

                if [ -n "$STARTED_AT" ]; then
                    local now=$(date +%s)
                    local diff=$((now - STARTED_AT))
                    local hours=$((diff / 3600))
                    local minutes=$(((diff % 3600) / 60))
                    echo "  ⏰ 실행 시간: ${hours}시간 ${minutes}분"
                fi

                echo ""
            else
                # 실행되지 않는 상태 파일 정리
                clear_state "$state_file"
            fi
        fi
    done

    if [ $count -eq 0 ]; then
        print_warning "실행 중인 인스턴스가 없습니다."
    else
        echo "총 ${count}개의 인스턴스가 실행 중입니다."
    fi

    echo ""
}

# 강제 종료 명령어 (다른 터미널에서 실행 중인 것을 종료)
cmd_kill() {
    local target="${1:-$PWD}"
    target="${target/#\~/$HOME}"
    target=$(cd "$target" 2>/dev/null && pwd || echo "$target")

    check_docker
    ensure_instances_dir

    local project_hash=$(get_project_hash "$target")
    local container_name="${project_hash}"
    local state_file=$(get_state_file "$project_hash")

    if ! is_project_running "$container_name"; then
        print_warning "이 프로젝트는 실행되고 있지 않습니다: $target"
        clear_state "$state_file"
        exit 0
    fi

    print_info "CodeKiwi 인스턴스를 강제 종료합니다: $target"

    docker stop "$container_name" 2>/dev/null || true
    docker rm "$container_name" 2>/dev/null || true

    clear_state "$state_file"

    print_success "인스턴스가 종료되었습니다."
}

# 모든 인스턴스 강제 종료
cmd_kill_all() {
    check_docker
    ensure_instances_dir

    print_info "모든 CodeKiwi 인스턴스를 종료합니다..."

    local count=0
    for state_file in $(get_all_instances); do
        if load_state "$state_file"; then
            if is_project_running "$CONTAINER_NAME"; then
                print_info "종료 중: $WORKSPACE_DIR"
                docker stop "$CONTAINER_NAME" 2>/dev/null || true
                docker rm "$CONTAINER_NAME" 2>/dev/null || true
                count=$((count + 1))
            fi
            clear_state "$state_file"
        fi
    done

    if [ $count -eq 0 ]; then
        print_warning "실행 중인 인스턴스가 없습니다."
    else
        print_success "$count개의 인스턴스를 종료했습니다."
    fi
}

# 업데이트 명령어
cmd_update() {
    print_info "CodeKiwi를 업데이트합니다..."

    # 실행 중인 인스턴스 확인
    local instances=$(get_all_instances)
    if [ -n "$instances" ]; then
        print_warning "실행 중인 인스턴스가 있습니다."
        echo "업데이트를 진행하면 모든 인스턴스가 종료됩니다."
        read -p "계속하시겠습니까? (y/n): " confirm

        if [ "$confirm" != "y" ] && [ "$confirm" != "Y" ]; then
            echo "취소되었습니다."
            exit 0
        fi

        cmd_kill_all
    fi

    # GitHub에서 최신 파일 다운로드
    local repo_url="${CODEKIWI_REPO_BASE_URL:-https://raw.githubusercontent.com/aardvarkdev1/codekiwi-cli/main}"

    print_info "CLI 파일을 업데이트합니다..."
    curl -fsSL "$repo_url/cli/bin/codekiwi" -o "$INSTALL_DIR/codekiwi"
    chmod +x "$INSTALL_DIR/codekiwi"

    print_info "설정 파일을 업데이트합니다..."
    curl -fsSL "$repo_url/config.env" -o "$INSTALL_DIR/config.env"

    print_info "config-loader를 업데이트합니다..."
    mkdir -p "$INSTALL_DIR/lib"
    curl -fsSL "$repo_url/lib/config-loader.sh" -o "$INSTALL_DIR/lib/config-loader.sh"

    print_info "docker-compose.yaml을 업데이트합니다..."
    curl -fsSL "$repo_url/docker-compose.yaml" -o "$INSTALL_DIR/docker-compose.yaml"

    print_info "Docker 이미지를 업데이트합니다..."
    local image_name="${CODEKIWI_FULL_IMAGE_NAME:-aardvarkdev1/codekiwi-runtime}"
    local image_tag="${CODEKIWI_IMAGE_TAG_DEFAULT:-latest}"
    docker pull "$image_name:$image_tag"

    print_success "업데이트가 완료되었습니다."
}

# 제거 명령어
cmd_uninstall() {
    echo "CodeKiwi를 제거하시겠습니까?"
    echo "설치 디렉토리 ($INSTALL_DIR)가 삭제됩니다."
    read -p "계속하시겠습니까? (y/n): " confirm

    if [ "$confirm" != "y" ] && [ "$confirm" != "Y" ]; then
        echo "취소되었습니다."
        exit 0
    fi

    # 모든 인스턴스 중지
    cmd_kill_all

    # 설치 디렉토리 삭제
    print_info "설치 파일을 삭제합니다..."
    rm -rf "$INSTALL_DIR"

    # 심볼릭 링크 삭제
    if [ -L "/usr/local/bin/codekiwi" ]; then
        sudo rm /usr/local/bin/codekiwi
    fi

    print_success "CodeKiwi가 제거되었습니다."
}

# 도움말
cmd_help() {
    cat << EOF
CodeKiwi - 웹 기반 개발 환경

사용법:
  codekiwi [directory]      현재 디렉토리 또는 지정한 디렉토리로 시작
                            (포그라운드로 실행, Ctrl+C로 종료)

  codekiwi list             실행 중인 모든 인스턴스 목록
  codekiwi kill [directory] 지정한 디렉토리의 인스턴스 강제 종료
  codekiwi kill --all       모든 인스턴스 강제 종료

  codekiwi update           최신 버전으로 업데이트
  codekiwi uninstall        CodeKiwi 제거
  codekiwi help             이 도움말 표시

예시:
  # 기본 사용 (opencode 스타일)
  cd ~/my-project
  codekiwi                  # 현재 디렉토리로 시작
                            # 터미널이 유지되고 로그 출력
                            # Ctrl+C로 종료

  # 여러 프로젝트 동시 실행
  # 터미널 1
  cd ~/project-a
  codekiwi

  # 터미널 2
  cd ~/project-b
  codekiwi

  # 터미널 3 (목록 확인)
  codekiwi list

  # 다른 터미널에서 강제 종료
  codekiwi kill ~/project-a

자세한 정보:
  https://github.com/aardvarkdev1/codekiwi-cli

EOF
}

# 메인 명령어 라우팅
main() {
    local cmd="${1:-}"
    local arg="${2:-}"

    case "$cmd" in
        list|ls)
            cmd_list
            ;;
        kill)
            if [ "$arg" = "--all" ] || [ "$arg" = "-a" ]; then
                cmd_kill_all
            else
                cmd_kill "$arg"
            fi
            ;;
        update)
            cmd_update
            ;;
        uninstall)
            cmd_uninstall
            ;;
        help|--help|-h)
            cmd_help
            ;;
        "")
            # 인자 없음 - 현재 디렉토리로 시작
            cmd_start
            ;;
        *)
            # 디렉토리 경로로 간주
            cmd_start "$cmd"
            ;;
    esac
}

main "$@"
